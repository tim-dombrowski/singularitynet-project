---
title: "SingularityNET Ecosystem Analysis"
date: "Last updated: `r Sys.Date()`"
output: html_notebook
---

## Preliminary Work: Install/Load Packages

To try and ensure that this R Notebook will run successfully, we'll use the [renv package](https://cran.r-project.org/web/packages/renv/index.html) to create a project-specific library of packages. This will allow us to install the packages that we need for this project without affecting any other projects that we may be working on. Additionally, the project library will track the specific versions of the dependency packages so that any updates to those packages will not break this project.

The code chunk below will first install the renv package if it is not already installed. Then we will load the package. Next, we'll use the `restore()` function to install any packages listed in the renv.lock file. Once these packages are installed, we can load them into the R session using the `library()` commands. Below the code chunk, we'll list out the packages that will be used in the project demo. And if you run into any trouble using renv, then you can use the second code chunk below and that should be an even more reliable approach to install the required packages.

```{r setup, results='hide', message=FALSE}
# Install renv package if not already installed
if(!"renv" %in% installed.packages()[,"Package"]) install.packages("renv")
# Load renv package
library(renv)
# Use restore() to install any packages listed in the renv.lock file
renv::restore(clean=TRUE, lockfile="../renv.lock")
# Load in the packages
library(quantmod)
library(tidyverse)
library(corrplot)
library(rmarkdown)
```

* The [quantmod package](https://cran.r-project.org/package=quantmod) contains tools for importing and analyzing financial data.
* The [tidyverse package](https://www.tidyverse.org/) contains a suite of packages for data manipulation and visualization.
* The [corrplot package](https://cran.r-project.org/package=corrplot) lets us create correlation plots.
* The [rmarkdown package](https://cran.r-project.org/package=rmarkdown) is used to g

Since the rmarkdown functionality is built into RStudio, this one is automatically loaded when we open the RStudio. So no need to use the `library()` function for this one. Another observation to make about the code chunk above is that it is labeled as 'setup', which is a special name, which the R Notebook will recognize and automatically run prior to running any other code chunk. This is useful for loading in packages and setting up other global options that will be used throughout the notebook. 

Then if you wish to try and update the versions of the various R packages in the lock file, you can use the `renv::update()` function to update the packages in the project library. However, it is possible that these updates could break the code in this notebook. If so, you may need to adapt the code to work with the updated packages.

My recommendation is to first run through the code using the versions of the packages in the lock file. Then if you want to try and update the packages, you can do so and then run through the code again to see if it still works. If not, you can always revert back to the lock file versions using the `renv::restore()` function.

If you update the packages and get everything working successfully, then you can update the lock file using the `renv::snapshot()` function. This will update the lock file with the versions of the packages that are currently installed in the project library. Then you can commit the updated lock file to the repository so that others can use the updated versions of the packages.

### Alternative Package Installation Code

If you run into any trouble using renv in the code chunk above, then you can use the code chunk below to install the required packages for this analysis. This method will first check if you have already installed the packages. If any are missing, it will then install them. Then it will load the packages into the R session. A potential flaw in this approach compared to using renv is that it will simply install the latest versions of the packages, which could potentially break some of the code in this notebook if any of the updates aren't backwards compatible. 

As long as you have downloaded the entire project repository, the renv chunk above will likely be managing the packages. Thus, the `eval=FALSE` option is used to prevent this chunk from running unless manually executed. So if you only downloaded this one Rmd file, this code chunk should take care of installing the packages for you.

```{r setup2, results='hide', message=FALSE, eval=FALSE}
# Create list of packages needed for this exercise, omit geckor since its not on CRAN
list.of.packages = c("quantmod","tidyverse","corrplot","rmarkdown")
# Check if any have not yet been installed
new.packages = list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
# If any need to be installed, install them
if(length(new.packages)) install.packages(new.packages)
library(quantmod)
library(tidyverse)
library(corrplot)
library(rmarkdown)
```


## Data Import and Cleaning

### Token Price Data

First, let's import the price data for all the SingularityNET ecosystem tokens, as well as the price data for Bitcoin (BTC), Ethereum (ETH), and the S&P 500 ETF (SPY). We'll use the `getSymbols()` function from the quantmod package to import the price data for these assets. This will download the price data from Yahoo Finance and store it in the R environment as xts objects.

```{r assetdata, results='hide'}
startdate = "2018-01-19"
tickers = c("AGIX-USD",
            "SDAO-USD",
            "NTX13198-USD",
            "RJV-USD",
            "HYPC-USD",
            "CGV-USD",
            "SOPH-USD",
            "BTC-USD",
            "ETH-USD",
            "SPY")
getSymbols(tickers,
           src="yahoo",
           from=startdate, # begin at start of AGIX price series
           to=Sys.Date())
```

As of June 2024, several tokens generate a warning message about some missing values in the data. Depending on the time of day that the code is run, the most recent observation can sometimes be missing. Then in addition to that, three of the tokens have a period of three days in September 2023 where the data is missing.

To more fully diagnose this issue, we can use the `complete.cases()` function to identify the rows with missing values. The following code chunk will output the rows with missing values for each of the tokens.

```{r diagnosewarnings}
`AGIX-USD`[!complete.cases(`AGIX-USD`),]
`SDAO-USD`[!complete.cases(`SDAO-USD`),]
`NTX13198-USD`[!complete.cases(`NTX13198-USD`),]
`RJV-USD`[!complete.cases(`RJV-USD`),]
`HYPC-USD`[!complete.cases(`HYPC-USD`),]
`CGV-USD`[!complete.cases(`CGV-USD`),]
`SOPH-USD`[!complete.cases(`SOPH-USD`),]
`BTC-USD`[!complete.cases(`BTC-USD`),]
`ETH-USD`[!complete.cases(`ETH-USD`),]
SPY[!complete.cases(SPY),]
```

To address the issue of the three missing observations in Sept. 2023, we can use the `na.approx()` function to fill those missing values using linear interpolation. Since this these three observations are within a single month, this should only have a minimal impact on the daily price series, and it will have no impact after zooming out to a monthly frequency. The following code chunk will apply this function to the three tokens with missing values.

```{r fixwarnings}
`HYPC-USD` = na.approx(`HYPC-USD`)
`CGV-USD` = na.approx(`CGV-USD`)
`SOPH-USD` = na.approx(`SOPH-USD`)
```

As for the most recent missing values, we will resolve that later after merging the return series together. But first, let's use the `to.monthly()` function from the xts package to convert the daily price data to monthly price data. This will allow us to analyze the data at a higher level of aggregation that is unaffected by those missing value imputations and captures more of the long-term dynamics in the token prices.

```{r assetcleaning, warning=FALSE}
AGIXdaily = `AGIX-USD`
AGIXmonth = to.monthly(AGIXdaily, name=NULL)
SDAOdaily = `SDAO-USD`
SDAOmonth = to.monthly(SDAOdaily, name=NULL)
NTXdaily = `NTX13198-USD`
NTXmonth = to.monthly(NTXdaily, name=NULL)
RJVdaily = `RJV-USD`
RJVmonth = to.monthly(RJVdaily, name=NULL)
HYPCdaily = `HYPC-USD`
HYPCmonth = to.monthly(HYPCdaily, name=NULL)
CGVdaily = `CGV-USD`
CGVmonth = to.monthly(CGVdaily, name=NULL)
SOPHdaily = `SOPH-USD`
SOPHmonth = to.monthly(SOPHdaily, name=NULL)
BTCdaily = `BTC-USD`
BTCmonth = to.monthly(BTCdaily, name=NULL)
ETHdaily = `ETH-USD`
ETHmonth = to.monthly(ETHdaily, name=NULL)
SPYdaily = SPY
SPYmonth = to.monthly(SPYdaily, name=NULL)
```

Another data cleaning step that we can take is to impute missing values in the daily SPY data for non-trading days. This will allow us to have a complete daily return series for the S&P 500 ETF. The following code chunk will create a daily xts object with the same length as the token data, merge the daily SPY observations, and impute missing values for the Adjusted close price using linear interpolation.

```{r imputespy}
# Create a daily xts object with the same length as the token data
SPYdaily2 = xts(order.by=seq(min(index(SPY)), length=nrow(BTCdaily), by="day"))
# Merge to daily SPY observations
SPYdaily2 = merge(SPYdaily2, SPYdaily)
# Impute missing values using linear interpolation
SPYdaily2$SPY.Adjusted = na.approx(SPYdaily2$SPY.Adjusted, na.rm=FALSE)
```

Now that we have each of the assets return series saved as daily and monthly series, let's compute the annualized returns for each. To do this, we can assume continuous compounding and use the log returns to calculate the annualized returns.

```{r assetreturns}
AGIXdaily$AnnRet = diff(log(AGIXdaily$`AGIX-USD.Adjusted`))*365*100
AGIXmonth$AnnRet = diff(log(AGIXmonth$Adjusted))*12*100
SDAOdaily$AnnRet = diff(log(SDAOdaily$`SDAO-USD.Adjusted`))*365*100
SDAOmonth$AnnRet = diff(log(SDAOmonth$Adjusted))*12*100
NTXdaily$AnnRet = diff(log(NTXdaily$`NTX13198-USD.Adjusted`))*365*100
NTXmonth$AnnRet = diff(log(NTXmonth$Adjusted))*12*100
RJVdaily$AnnRet = diff(log(RJVdaily$`RJV-USD.Adjusted`))*365*100
RJVmonth$AnnRet = diff(log(RJVmonth$Adjusted))*12*100
HYPCdaily$AnnRet = diff(log(HYPCdaily$`HYPC-USD.Adjusted`))*365*100
HYPCmonth$AnnRet = diff(log(HYPCmonth$Adjusted))*12*100
CGVdaily$AnnRet = diff(log(CGVdaily$`CGV-USD.Adjusted`))*365*100
CGVmonth$AnnRet = diff(log(CGVmonth$Adjusted))*12*100
SOPHdaily$AnnRet = diff(log(SOPHdaily$`SOPH-USD.Adjusted`))*365*100
SOPHmonth$AnnRet = diff(log(SOPHmonth$Adjusted))*12*100
BTCdaily$AnnRet = diff(log(BTCdaily$`BTC-USD.Adjusted`))*365*100
BTCmonth$AnnRet = diff(log(BTCmonth$Adjusted))*12*100
ETHdaily$AnnRet = diff(log(ETHdaily$`ETH-USD.Adjusted`))*365*100
ETHmonth$AnnRet = diff(log(ETHmonth$Adjusted))*12*100
SPYdaily2$AnnRet = diff(log(SPYdaily2$SPY.Adjusted))*365*100
SPYmonth$AnnRet = diff(log(SPYmonth$Adjusted))*12*100
```

### Economic Data

Now let's collect some economic from [FRED](https://fred.stlouisfed.org/) to help us analyze the data. We will import data for the Consumer Price Index (CPI) and the 10-year Treasury yield. The CPI data will be used to compute monthly inflation rates, and the 10-year Treasury yields will be used to represent the risk-free rate of return.

```{r econdata}
fredassets = c("CPIAUCSL","DGS10")
getSymbols(fredassets[1],
           src="FRED",
           from=as.Date(startdate) %m-% months(2), # begin two months before AGIX price series
           to=Sys.Date())
getSymbols(fredassets[2],
           src="FRED",
           from=startdate,
           to=Sys.Date())
```

The CPI is short for the Consumer Price Index. This units of this data is price levels. so to obtain monthly inflation rates, by taking the log difference of the CPI series and annualizing it.

```{r inflationcleaning}
# Compute the annualized inflation rate in percentage units
INFmonth = diff(log(CPIAUCSL))*12*100
# Create a daily xts object with the same length as the stock data
INFdaily = xts(order.by=seq(min(index(INFmonth)), length=nrow(BTCdaily), by="day"))
# Merge to monthly inflation observations
INFdaily = merge(INFdaily, INFmonth)
# Impute missing values using linear interpolation
INFdaily = na.approx(INFdaily, na.rm = FALSE)
```

Now for the 10-year Treasury yield. Unlike the stock and CPI variables, which are measured in prices or levels, the yields are already in the form of annualized returns with percentage units. Then as was done for the missing token data, we can use linear interpolation to fill in the missing values in the 10-year Treasury yield series. The following code chunk will apply this function to the 10-year Treasury yield series.

```{r dgs10daily}
# Create a daily xts object with the same length as the stock data
DGS10daily = xts(order.by=seq(min(index(DGS10)), length=nrow(BTCdaily), by="day"))
# Merge to monthly inflation observations
DGS10daily = merge(DGS10daily, DGS10)
# Impute missing values using linear interpolation
DGS10daily = na.approx(DGS10daily, na.rm=FALSE)
```

Next, instead of using `to.monthly()` to convert the daily series into a monthly OHLC xts object, it'd be more appropriate to use the monthly average yield. This is done below using some tools from the dplyr and lubridate packages.

```{r dgs10month, warning=FALSE}
# Generate monthly OHLC data for the 10-year treasury yield
DGS10month = to.monthly(DGS10daily, name=NULL)
# Aggregate to monthly frequency and compute means
DGS10dailydf = as.data.frame(DGS10daily)
DGS10dailydf$date = index(DGS10daily)
DGS10monthmean =  mutate(DGS10dailydf, date =floor_date(date,"month")) |> 
  group_by(date) |> summarise(DGS10 = mean(DGS10, na.rm=TRUE))
# Add the means to the monthly xts object
DGS10month$Mean = DGS10monthmean$DGS10
```

### Merging Data

Now that we have the return series for the SingularityNET tokens, as well as the economic data, we can merge them all together into a single data frame. This will allow us to analyze the relationships between the token returns and the economic data.

```{r mergedata}
# Merge the daily return series
daily_annrets = merge(AGIXdaily$AnnRet,
                      SDAOdaily$AnnRet,
                      NTXdaily$AnnRet,
                      RJVdaily$AnnRet,
                      HYPCdaily$AnnRet,
                      CGVdaily$AnnRet,
                      SOPHdaily$AnnRet,
                      BTCdaily$AnnRet,
                      ETHdaily$AnnRet,
                      SPYdaily2$AnnRet,
                      INFdaily$CPIAUCSL,
                      DGS10daily$DGS10
                      )
colnames(daily_annrets) = c("AGIX","SDAO","NTX","RJV","HYPC","CGV","SOPH","BTC","ETH","SPY","INF","RF")
# Merge the monthly return series
month_annrets = merge(AGIXmonth$AnnRet,
                      SDAOmonth$AnnRet,
                      NTXmonth$AnnRet,
                      RJVmonth$AnnRet,
                      HYPCmonth$AnnRet,
                      CGVmonth$AnnRet,
                      SOPHmonth$AnnRet,
                      BTCmonth$AnnRet,
                      ETHmonth$AnnRet,
                      SPYmonth$AnnRet,
                      INFmonth$CPIAUCSL,
                      DGS10month$Mean
                      )
colnames(month_annrets) = c("AGIX","SDAO","NTX","RJV","HYPC","CGV","SOPH","BTC","ETH","SPY","INF","RF")
```


## Multivariate Return Distributions

### Nominal Returns

Compute the average annual return and volatility of each of the coins/tokens, as well as the correlation matrix, for the daily return series.

```{r dailycors}
# Compute average annual returns, volatility, and correlations
Er_daily = colMeans(daily_annrets,na.rm=TRUE)
Er_daily |> round(2)
sd_daily = apply(daily_annrets,2,sd,na.rm=TRUE)
sd_daily |> round(2)
Sharpe_daily = Er_daily/sd_daily
Sharpe_daily |> round(2)
cor(daily_annrets, use="pairwise.complete.obs") |> round(2)
corrplot(cor(daily_annrets, use="pairwise.complete"), method="color")
```

Compute the average annual return and volatility of each of the coins/tokens, as well as the correlation matrix, for the monthly return series.

```{r monthlycors}
# Compute average annual returns, volatility, and correlations
Er_month = colMeans(month_annrets,na.rm=TRUE)
Er_month |> round(2)
sd_month = apply(month_annrets,2,sd,na.rm=TRUE)
sd_month |> round(2)
Sharpe_month = Er_month/sd_month
Sharpe_month |> round(2)
cor(month_annrets, use="pairwise.complete.obs") |> round(2)
corrplot(cor(month_annrets, use="pairwise.complete"), method="color")
```

### Real Returns

Now let's compute the real returns for each of the coins/tokens by subtracting the inflation rate from the nominal returns. This will allow us to analyze the real returns of the tokens after adjusting for inflation.


















## ETH-adjusted Returns

Now let's examine the relationship of the returns on the SingularityNET tokens to that of Ethereum, which is the blockchain that the tokens primarily transact on.

First up is the SingularityNET token (AGIX):

```{r agixregs}
AGIXfit_daily = lm(AGIX~ETH, data=daily_annrets)
summary(AGIXfit_daily)
ggplot(daily_annrets,aes(y=AGIX, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$AGIXresid = xts(resid(AGIXfit_daily), order.by=as.Date(names(resid(AGIXfit_daily))))

AGIXfit_month = lm(AGIX~ETH, data=month_annrets)
summary(AGIXfit_month)
ggplot(month_annrets,aes(y=AGIX, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets2 = data.frame(date=names(resid(AGIXfit_month)))
month_annrets2$AGIXresids = resid(AGIXfit_month)
```

Next is the SingularityDAO token (SDAO):

```{r sdaoregs}
SDAOfit_daily = lm(SDAO~ETH, data=daily_annrets)
summary(SDAOfit_daily)
ggplot(daily_annrets,aes(y=SDAO, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$SDAOresid = xts(resid(SDAOfit_daily), order.by=as.Date(names(resid(SDAOfit_daily))))

SDAOfit_weeks = lm(SDAO~ETH, data=weeks_annrets)
summary(SDAOfit_weeks)
ggplot(weeks_annrets,aes(y=SDAO, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$SDAOresids = xts(resid(SDAOfit_weeks), order.by=as.Date(names(resid(SDAOfit_weeks))))

SDAOfit_month = lm(SDAO~ETH, data=month_annrets)
summary(SDAOfit_month)
ggplot(month_annrets,aes(y=SDAO, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(SDAOfit_month)))
month_annrets3$SDAOresids = resid(SDAOfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

Then the NuNet token (NTX):

```{r ntxregs}
NTXfit_daily = lm(NTX~ETH, data=daily_annrets)
summary(NTXfit_daily)
ggplot(daily_annrets,aes(y=NTX, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$NTXresid = xts(resid(NTXfit_daily), order.by=as.Date(names(resid(NTXfit_daily))))

NTXfit_weeks = lm(NTX~ETH, data=weeks_annrets)
summary(NTXfit_weeks)
ggplot(weeks_annrets,aes(y=NTX, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$NTXresids = xts(resid(NTXfit_weeks), order.by=as.Date(names(resid(NTXfit_weeks))))

NTXfit_month = lm(NTX~ETH, data=month_annrets)
summary(NTXfit_month)
ggplot(month_annrets,aes(y=NTX, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(NTXfit_month)))
month_annrets3$NTXresids = resid(NTXfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

Next is the Rejuve token (RJV):

```{r rjvregs}
RJVfit_daily = lm(RJV~ETH, data=daily_annrets)
summary(RJVfit_daily)
ggplot(daily_annrets,aes(y=RJV, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$RJVresid = xts(resid(RJVfit_daily), order.by=as.Date(names(resid(RJVfit_daily))))

RJVfit_weeks = lm(RJV~ETH, data=weeks_annrets)
summary(RJVfit_weeks)
ggplot(weeks_annrets,aes(y=RJV, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$RJVresids = xts(resid(RJVfit_weeks), order.by=as.Date(names(resid(RJVfit_weeks))))

RJVfit_month = lm(RJV~ETH, data=month_annrets)
summary(RJVfit_month)
ggplot(month_annrets,aes(y=RJV, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(RJVfit_month)))
month_annrets3$RJVresids = resid(RJVfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

Then the HyperCycle token (HYPC):

```{r hypcregs}
HYPCfit_daily = lm(HYPC~ETH, data=daily_annrets)
summary(HYPCfit_daily)
ggplot(daily_annrets,aes(y=HYPC, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$HYPCresid = xts(resid(HYPCfit_daily), order.by=as.Date(names(resid(HYPCfit_daily))))

HYPCfit_weeks = lm(HYPC~ETH, data=weeks_annrets)
summary(HYPCfit_weeks)
ggplot(weeks_annrets,aes(y=HYPC, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$HYPCresids = xts(resid(HYPCfit_weeks), order.by=as.Date(names(resid(HYPCfit_weeks))))

HYPCfit_month = lm(HYPC~ETH, data=month_annrets)
summary(HYPCfit_month)
ggplot(month_annrets,aes(y=HYPC, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(HYPCfit_month)))
month_annrets3$HYPCresids = resid(HYPCfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

Next is the Cogito token (CGV):

```{r cgvregs}
CGVfit_daily = lm(CGV~ETH, data=daily_annrets)
summary(CGVfit_daily)
ggplot(daily_annrets,aes(y=CGV, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$CGVresid = xts(resid(CGVfit_daily), order.by=as.Date(names(resid(CGVfit_daily))))

CGVfit_weeks = lm(CGV~ETH, data=weeks_annrets)
summary(CGVfit_weeks)
ggplot(weeks_annrets,aes(y=CGV, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$CGVresids = xts(resid(CGVfit_weeks), order.by=as.Date(names(resid(CGVfit_weeks))))

CGVfit_month = lm(CGV~ETH, data=month_annrets)
summary(CGVfit_month)
ggplot(month_annrets,aes(y=CGV, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(CGVfit_month)))
month_annrets3$CGVresids = resid(CGVfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

Lastly is the Sophiaverse token (SOPH):

```{r sophregs}
SOPHfit_daily = lm(SOPH~ETH, data=daily_annrets)
summary(SOPHfit_daily)
ggplot(daily_annrets,aes(y=SOPH, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$SOPHresid = xts(resid(SOPHfit_daily), order.by=as.Date(names(resid(SOPHfit_daily))))

SOPHfit_weeks = lm(SOPH~ETH, data=weeks_annrets)
summary(SOPHfit_weeks)
ggplot(weeks_annrets,aes(y=SOPH, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$SOPHresids = xts(resid(SOPHfit_weeks), order.by=as.Date(names(resid(SOPHfit_weeks))))

SOPHfit_month = lm(SOPH~ETH, data=month_annrets)
summary(SOPHfit_month)
ggplot(month_annrets,aes(y=SOPH, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(SOPHfit_month)))
month_annrets3$SOPHresids = resid(SOPHfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

Lastly, let's look at the ecosystem as a whole:

```{r snetregs}
SNETfit_daily = lm(SNET~ETH, data=daily_annrets)
summary(SNETfit_daily)
ggplot(daily_annrets,aes(y=SNET, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$SNETresid = xts(resid(SNETfit_daily), order.by=as.Date(names(resid(SNETfit_daily))))

SNETfit_weeks = lm(SNET~ETH, data=weeks_annrets)
summary(SNETfit_weeks)
ggplot(weeks_annrets,aes(y=SNET, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$SNETresids = xts(resid(SNETfit_weeks), order.by=as.Date(names(resid(SNETfit_weeks))))

SNETfit_month = lm(SNET~ETH, data=month_annrets)
summary(SNETfit_month)
ggplot(month_annrets,aes(y=SNET, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(SNETfit_month)))
month_annrets3$SNETresids = resid(SNETfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

### Residual Correlations

Now that we have the residual series for each of the coins/tokens, let's look at the correlations between them. These represent the correlations of the asset returns after removing the effects that are explained by their relationship with Ethereum.

```{r dailyresidcors}
cor(daily_annrets[,10:17], use="pairwise.complete.obs") |> round(2)
```

```{r weeksresidcors}
cor(weeks_annrets[,10:17], use="pairwise.complete.obs") |> round(2)
```

```{r monthresidcors}
cor(month_annrets2[,-1], use="pairwise.complete.obs") |> round(2)
```

