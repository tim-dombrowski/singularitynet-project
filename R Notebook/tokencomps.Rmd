---
title: "SingularityNET Ecosystem Analysis"
date: "Last updated: `r Sys.Date()`"
output: html_notebook
---

## Preliminary Work: Install/Load Packages

To try and ensure that this R Notebook will run successfully, we'll use the [renv package](https://cran.r-project.org/web/packages/renv/index.html) to create a project-specific library of packages. This will allow us to install the packages that we need for this project without affecting any other projects that we may be working on. Additionally, the project library will track the specific versions of the dependency packages so that any updates to those packages will not break this project.

The code chunk below will first install the renv package if it is not already installed. Then we will load the package. Next, we'll use the `restore()` function to install any packages listed in the renv.lock file. Once these packages are installed, we can load them into the R session using the `library()` commands. Below the code chunk, we'll list out the packages that will be used in the project demo. And if you run into any trouble using renv, then you can use the second code chunk below and that should be an even more reliable approach to install the required packages.

```{r setup, results='hide', message=FALSE}
# Install renv package if not already installed
if(!"renv" %in% installed.packages()[,"Package"]) install.packages("renv")
# Load renv package
library(renv)
# Use restore() to install any packages listed in the renv.lock file
renv::restore(clean=TRUE, lockfile="../renv.lock")
# Load in the packages
library(quantmod)
library(tidyverse)
library(scales)
library(corrplot)
library(rmarkdown)
```

* The [quantmod package](https://cran.r-project.org/package=quantmod) contains tools for importing and analyzing financial data.
* The [tidyverse package](https://www.tidyverse.org/) contains a suite of packages for data manipulation and visualization.
* The [scales package](https://cran.r-project.org/package=scales) 
* The [corrplot package](https://cran.r-project.org/package=corrplot) lets us create correlation plots.
* The [rmarkdown package](https://cran.r-project.org/package=rmarkdown) is used to g

Since the rmarkdown functionality is built into RStudio, this one is automatically loaded when we open the RStudio. So no need to use the `library()` function for this one. Another observation to make about the code chunk above is that it is labeled as 'setup', which is a special name, which the R Notebook will recognize and automatically run prior to running any other code chunk. This is useful for loading in packages and setting up other global options that will be used throughout the notebook. 

Then if you wish to try and update the versions of the various R packages in the lock file, you can use the `renv::update()` function to update the packages in the project library. However, it is possible that these updates could break the code in this notebook. If so, you may need to adapt the code to work with the updated packages.

My recommendation is to first run through the code using the versions of the packages in the lock file. Then if you want to try and update the packages, you can do so and then run through the code again to see if it still works. If not, you can always revert back to the lock file versions using the `renv::restore()` function.

If you update the packages and get everything working successfully, then you can update the lock file using the `renv::snapshot()` function. This will update the lock file with the versions of the packages that are currently installed in the project library. Then you can commit the updated lock file to the repository so that others can use the updated versions of the packages.

### Alternative Package Installation Code

If you run into any trouble using renv in the code chunk above, then you can use the code chunk below to install the required packages for this analysis. This method will first check if you have already installed the packages. If any are missing, it will then install them. Then it will load the packages into the R session. A potential flaw in this approach compared to using renv is that it will simply install the latest versions of the packages, which could potentially break some of the code in this notebook if any of the updates aren't backwards compatible. 

As long as you have downloaded the entire project repository, the renv chunk above will likely be managing the packages. Thus, the `eval=FALSE` option is used to prevent this chunk from running unless manually executed. So if you only downloaded this one Rmd file, this code chunk should take care of installing the packages for you.

```{r setup2, results='hide', message=FALSE, eval=FALSE}
# Create list of packages needed for this exercise, omit geckor since its not on CRAN
list.of.packages = c("quantmod","tidyverse","corrplot","rmarkdown")
# Check if any have not yet been installed
new.packages = list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
# If any need to be installed, install them
if(length(new.packages)) install.packages(new.packages)
library(quantmod)
library(tidyverse)
library(corrplot)
library(rmarkdown)
```


## Data Import and Cleaning

### Token Price Data

First, let's import the price data for all the SingularityNET ecosystem tokens, as well as the price data for Bitcoin (BTC), Ethereum (ETH), an S&P 500 ETF (SPY), and Nvidia stock (NVDA). These additional assets will allow us to compare these SingularityNET tokens with some other related assets. We'll use the `getSymbols()` function from the quantmod package to import the price data for these assets. This will download the price data from Yahoo Finance and store it in the R environment as xts objects.

```{r assetdata, results='hide'}
startdate = "2018-01-19" # begin at start of AGIX price series
tickers = c("AGIX-USD",
            "SDAO-USD",
            "NTX13198-USD",
            "RJV-USD",
            "HYPC-USD",
            "CGV-USD",
            "SOPH-USD",
            "BTC-USD",
            "ETH-USD",
            "SPY",
            "NVDA")
getSymbols(tickers,
           src="yahoo",
           from=startdate,
           to=Sys.Date())
```

As of June 2024, several tokens generate warning messages about some missing values in the data. So let's diagnose these issues. The code chunk below will use the `complete.cases()` function to identify the rows with missing values for each of the tokens.

```{r diagnosewarnings}
`AGIX-USD`[!complete.cases(`AGIX-USD`),]
`SDAO-USD`[!complete.cases(`SDAO-USD`),]
`NTX13198-USD`[!complete.cases(`NTX13198-USD`),]
`RJV-USD`[!complete.cases(`RJV-USD`),]
`HYPC-USD`[!complete.cases(`HYPC-USD`),]
`CGV-USD`[!complete.cases(`CGV-USD`),]
`SOPH-USD`[!complete.cases(`SOPH-USD`),]
`BTC-USD`[!complete.cases(`BTC-USD`),]
`ETH-USD`[!complete.cases(`ETH-USD`),]
SPY[!complete.cases(SPY),]
NVDA[!complete.cases(NVDA),]
```

Depending on the time of day that these codes are run, the most recent observation can sometimes be missing. For now, we can leave these as is since it will be addressed at a later stage in the data cleaning process.

The more pressing issue with the missing values (as of June 2024) is that three of the tokens (HYPC, CGV, and SOPH) have a period of three days in September 2023 where the data is missing. Since this occurs in the middle of the series, those would end up flowing through to the final cleaned data. So let's address this issue here.

To address the issue of the three missing observations in Sept. 2023, we can use the `na.approx()` function to fill those missing values using linear interpolation. Since this these three observations are within a single month, this should only have a minimal impact on the daily price series, and it will have no impact after zooming out to a monthly frequency. The following code chunk will apply this function to the three tokens with missing values.

```{r fixwarnings}
`HYPC-USD` = na.approx(`HYPC-USD`)
`CGV-USD` = na.approx(`CGV-USD`)
`SOPH-USD` = na.approx(`SOPH-USD`)
```

As for the most recent missing values, we will resolve that later after merging the return series together. But first, let's use the `to.monthly()` function from the xts package to convert the daily price data to monthly price data. This will allow us to analyze the data at a higher level of aggregation that is unaffected by those missing value imputations and captures more of the long-term dynamics in the token prices.

```{r assetcleaning, warning=FALSE}
AGIXdaily = `AGIX-USD`
AGIXmonth = to.monthly(AGIXdaily, name=NULL)
SDAOdaily = `SDAO-USD`
SDAOmonth = to.monthly(SDAOdaily, name=NULL)
NTXdaily = `NTX13198-USD`
NTXmonth = to.monthly(NTXdaily, name=NULL)
RJVdaily = `RJV-USD`
RJVmonth = to.monthly(RJVdaily, name=NULL)
HYPCdaily = `HYPC-USD`
HYPCmonth = to.monthly(HYPCdaily, name=NULL)
CGVdaily = `CGV-USD`
CGVmonth = to.monthly(CGVdaily, name=NULL)
SOPHdaily = `SOPH-USD`
SOPHmonth = to.monthly(SOPHdaily, name=NULL)
BTCdaily = `BTC-USD`
BTCmonth = to.monthly(BTCdaily, name=NULL)
ETHdaily = `ETH-USD`
ETHmonth = to.monthly(ETHdaily, name=NULL)
SPYdaily = SPY
SPYmonth = to.monthly(SPYdaily, name=NULL)
NVDAdaily = NVDA
NVDAmonth = to.monthly(NVDAdaily, name=NULL)
```

Another data cleaning step to address is the mismatch in trading days for crypto-assets and traditional securities. In other words, crypto markets are observed 24/7, 365 days a year, while traditional markets are only open on weekdays. Thus, SPY and NVDA will have many missing values on weekends and holidays. 

To address this issue, we can impute missing values in the daily SPY and NVDA data for non-trading days. This will allow us to have a complete daily price series for the S&P 500 ETF and Nvidia stock. The following code chunk will create a daily xts object with the same length as the token data, merge the daily SPY and NVDA observations, and impute missing values for the Adjusted close price using linear interpolation.

```{r imputespy}
# Create a daily xts object with the same length as the token data
SPYdaily2 = xts(order.by=seq(min(index(SPY)), length=nrow(BTCdaily), by="day"))
# Merge to daily SPY observations
SPYdaily2 = merge(SPYdaily2, SPYdaily)
# Impute missing values using linear interpolation
SPYdaily2$SPY.Adjusted = na.approx(SPYdaily2$SPY.Adjusted, na.rm=FALSE)
# Same for NVDA
NVDAdaily2 = xts(order.by=seq(min(index(NVDA)), length=nrow(BTCdaily), by="day"))
NVDAdaily2 = merge(NVDAdaily2, NVDAdaily)
NVDAdaily2$NVDA.Adjusted = na.approx(NVDAdaily2$NVDA.Adjusted, na.rm=FALSE)
```

Now that we have each of the assets return series saved as daily and monthly series, let's compute the annualized returns for each. To do this, we can assume continuous compounding and use the log returns to calculate the annualized returns.

```{r assetreturns}
AGIXdaily$AnnRet = diff(log(AGIXdaily$`AGIX-USD.Adjusted`))*365*100
AGIXmonth$AnnRet = diff(log(AGIXmonth$Adjusted))*12*100
SDAOdaily$AnnRet = diff(log(SDAOdaily$`SDAO-USD.Adjusted`))*365*100
SDAOmonth$AnnRet = diff(log(SDAOmonth$Adjusted))*12*100
NTXdaily$AnnRet = diff(log(NTXdaily$`NTX13198-USD.Adjusted`))*365*100
NTXmonth$AnnRet = diff(log(NTXmonth$Adjusted))*12*100
RJVdaily$AnnRet = diff(log(RJVdaily$`RJV-USD.Adjusted`))*365*100
RJVmonth$AnnRet = diff(log(RJVmonth$Adjusted))*12*100
HYPCdaily$AnnRet = diff(log(HYPCdaily$`HYPC-USD.Adjusted`))*365*100
HYPCmonth$AnnRet = diff(log(HYPCmonth$Adjusted))*12*100
CGVdaily$AnnRet = diff(log(CGVdaily$`CGV-USD.Adjusted`))*365*100
CGVmonth$AnnRet = diff(log(CGVmonth$Adjusted))*12*100
SOPHdaily$AnnRet = diff(log(SOPHdaily$`SOPH-USD.Adjusted`))*365*100
SOPHmonth$AnnRet = diff(log(SOPHmonth$Adjusted))*12*100
BTCdaily$AnnRet = diff(log(BTCdaily$`BTC-USD.Adjusted`))*365*100
BTCmonth$AnnRet = diff(log(BTCmonth$Adjusted))*12*100
ETHdaily$AnnRet = diff(log(ETHdaily$`ETH-USD.Adjusted`))*365*100
ETHmonth$AnnRet = diff(log(ETHmonth$Adjusted))*12*100
SPYdaily2$AnnRet = diff(log(SPYdaily2$SPY.Adjusted))*365*100
SPYmonth$AnnRet = diff(log(SPYmonth$Adjusted))*12*100
NVDAdaily2$AnnRet = diff(log(NVDAdaily2$NVDA.Adjusted))*365*100
NVDAmonth$AnnRet = diff(log(NVDAmonth$Adjusted))*12*100
```

### Economic Data

Now let's collect some economic from [FRED](https://fred.stlouisfed.org/) to help us analyze the data. We will import data for the Consumer Price Index (CPI) and the 10-year Treasury yield. The CPI data will be used to compute inflation rates, and the 10-year Treasury yields will be used to represent the risk-free rate of return. *Note: since we will be imputing daily inflation rates from the monthly data, we need to get a couple extra months of CPI data. The `%m-%` operator is part of the lubridate package and let's us conduct date-math easily.*

```{r econdata}
fredassets = c("CPIAUCSL","DGS10")
getSymbols(fredassets[1],
           src="FRED",
           from=as.Date(startdate) %m-% months(2), # begin two months before AGIX price series
           to=Sys.Date())
getSymbols(fredassets[2],
           src="FRED",
           from=startdate,
           to=Sys.Date())
```

#### Inflation Cleaning

The CPI is short for the Consumer Price Index. This units of this data is price levels. so to obtain monthly inflation rates, we can take the difference in the logs of the CPI series and annualize it. This computes the continuously compounded annual growth rate at a monthly frequency.

```{r inflationmonth}
# Compute the annualized inflation rate in percentage units
INFmonth = diff(log(CPIAUCSL))*12*100
```

##### Aside: Imputation Methods for Daily Inflation Rates

Since this inflation data is only available at a monthly frequency, we need to determine what method to use for imputing daily observations. Let's explore a few options here.

* The most trivial method for this is to just use the same value for the entire month, which effectively assumes that there is no within-month variation in price growth. This method is also known as the "last observation carried forward" method and can be implemented with `na.locf()`. 
* A more sophisticated method would be to use linear interpolation to fill in the missing values. As suggested by the name, this assumes that price growth moves linearly between the observed values. This method can be implemented with `na.approx()`.
* Another more complex method is to use a cubic spline interpolation, which assumes that price growth moves smoothly between the observed values with non-linear dynamics. This method can be implemented with `na.spline()`.

The following code chunk will apply each of the three methods to the monthly inflation series and plot the results.

```{r infimputing}
# Create a daily xts object
INFdaily = xts(order.by=index(BTCdaily))
#INFdaily = xts(order.by=seq(min(index(INFmonth)), length=nrow(BTCdaily), by="day"))
# Merge to monthly inflation observations
INFdaily = merge(INFdaily, INFmonth)
# Impute missing values using the locf method
INFdaily1 = na.locf(INFdaily, na.rm = FALSE)
# Impute missing values using linear interpolation
INFdaily2 = na.approx(INFdaily, na.rm = FALSE)
# Impute missing values using cubic spline interpolation
INFdaily3 = na.spline(INFdaily, na.rm = FALSE)
# Plot the three daily series to compare imputation methods
ggplot(INFdaily1, aes(x=index(INFdaily1))) +
  # locf is black line
  geom_line(aes(y=INFdaily1$CPIAUCSL, color = "LOCF"), na.rm = TRUE) +
  # linear is red line
  geom_line(aes(y=INFdaily2$CPIAUCSL, color = "Linear"), na.rm = TRUE) +
  # spline is blue line
  geom_line(aes(y=INFdaily3$CPIAUCSL, color = "Spline"), na.rm = TRUE) +
  labs(title="Imputation of Daily Inflation Rates",
       x="",
       y="Annualized Inflation Rate",
       color = "Method") +
  scale_color_manual(values = c("LOCF" = "black", "Linear" = "red", "Spline" = "blue"))
```

From the plot above, you can see the differences between the three imputation methods. Additionally, we can compute the correlation matrix between the three daily inflation series to see how closely they are related.

```{r imputecorrs}
INFdailys = data.frame(INFdaily1$CPIAUCSL,
                       INFdaily2$CPIAUCSL,
                       INFdaily3$CPIAUCSL)
names(INFdailys) = c("LOCF","Linear","Spline")
cor(INFdailys, 
    use="pairwise.complete") |> round(2)
```

Based on the correlation matrix above, the linear and spline methods are highly correlated with each other, while the locf method is less correlated with the other two. Moving forward, I'll utilize the linear method since it provides within-month variation, but does not have extreme behavior in the tails like the spline method.

```{r infdaily}
INFdaily = INFdaily2
```

#### Treasury Yield Cleaning

Now for the 10-year Treasury yield. Unlike the stock and CPI variables, which are measured in prices or levels, the yields are already in the form of annualized returns with percentage units. Then as was done for the missing token data, we can use linear interpolation to fill in the missing values in the 10-year Treasury yield series. The following code chunk will apply this function to the 10-year Treasury yield series.

```{r dgs10daily}
# Create a daily xts object with the same length as the stock data
DGS10daily = xts(order.by=seq(min(index(DGS10)), length=nrow(BTCdaily), by="day"))
# Merge to monthly inflation observations
DGS10daily = merge(DGS10daily, DGS10)
# Impute missing values using linear interpolation
DGS10daily = na.approx(DGS10daily, na.rm=FALSE)
```

Next, instead of using `to.monthly()` to convert the daily series into a monthly OHLC xts object, it'd be more appropriate to use the monthly average yield. This is done below using some tools from the dplyr and lubridate packages.

```{r dgs10month, warning=FALSE}
# Generate monthly OHLC data for the 10-year treasury yield
DGS10month = to.monthly(DGS10daily, name=NULL)
# Aggregate to monthly frequency and compute means
DGS10dailydf = as.data.frame(DGS10daily)
DGS10dailydf$date = index(DGS10daily)
DGS10monthmean =  mutate(DGS10dailydf, date =floor_date(date,"month")) |> 
  group_by(date) |> summarise(DGS10 = mean(DGS10, na.rm=TRUE))
# Add the means to the monthly xts object
DGS10month$Mean = DGS10monthmean$DGS10
```

### Merging Data

Now that we have the return series for the SingularityNET tokens, as well as the economic data, we can merge them all together into a single data frame. This will allow us to analyze the relationships between the token returns and the economic data.

```{r mergedata}
# Merge the daily return series
daily_annrets = merge(AGIXdaily$AnnRet,
                      SDAOdaily$AnnRet,
                      NTXdaily$AnnRet,
                      RJVdaily$AnnRet,
                      HYPCdaily$AnnRet,
                      CGVdaily$AnnRet,
                      SOPHdaily$AnnRet,
                      BTCdaily$AnnRet,
                      ETHdaily$AnnRet,
                      SPYdaily2$AnnRet,
                      NVDAdaily2$AnnRet,
                      INFdaily$CPIAUCSL,
                      DGS10daily$DGS10
                      )
colnames(daily_annrets) = c("AGIX","SDAO","NTX","RJV","HYPC","CGV","SOPH","BTC","ETH","SPY","NVDA","INF","RF")
# Merge the monthly return series
month_annrets = merge(AGIXmonth$AnnRet,
                      SDAOmonth$AnnRet,
                      NTXmonth$AnnRet,
                      RJVmonth$AnnRet,
                      HYPCmonth$AnnRet,
                      CGVmonth$AnnRet,
                      SOPHmonth$AnnRet,
                      BTCmonth$AnnRet,
                      ETHmonth$AnnRet,
                      SPYmonth$AnnRet,
                      NVDAmonth$AnnRet,
                      INFmonth$CPIAUCSL,
                      DGS10month$Mean
                      )
colnames(month_annrets) = c("AGIX","SDAO","NTX","RJV","HYPC","CGV","SOPH","BTC","ETH","SPY","NVDA","INF","RF")
```

### Final Data Cleaning

As some final cleaning steps, let's create two variations of each frequency's final dataset spanning two time ranges: full and complete. The full dataset will include all observations with observed AGIX returns and inflation rates, while the complete dataset will only include observations where all tokens have price data. The full version will allow us to compute correlations and conduct analysis with the maximium amount of data, while the complete version will enable more comparable comparisons since each pair/correlation will be based on the same number of observations and the same time range.

```{r finalcleaning}
# Full data has non-missing crypto returns and inflation data
daily_annrets_full = daily_annrets[!is.na(daily_annrets$AGIX) & !is.na(daily_annrets$INF),]
month_annrets_full = month_annrets[!is.na(month_annrets$AGIX) & !is.na(month_annrets$INF),]
# Create subsets with only complete cases 
daily_annrets_complete = daily_annrets[complete.cases(daily_annrets),]
month_annrets_complete = month_annrets[complete.cases(month_annrets),]
```


## Analysis

### Univariate Return Distributions

Let's start by examining the univariate return distributions for all the assets.

To start, let's compute the average annual return for each of the assets in each of the four final versions of the data:

* Daily returns over full time series
* Daily returns for complete observations
* Monthly returns over full time series
* Monthly returns for complete observations

```{r nominalmeans}
colMeans(daily_annrets_full, na.rm=TRUE) |> round(2)
colMeans(daily_annrets_complete, na.rm=TRUE) |> round(2)
colMeans(month_annrets_full, na.rm=TRUE) |> round(2)
colMeans(month_annrets_complete, na.rm=TRUE) |> round(2)
```

Next, let's measure the volatilities:

```{r nominalvols}
apply(daily_annrets_full,2,sd,na.rm=TRUE) |> round(2)
apply(daily_annrets_complete,2,sd,na.rm=TRUE) |> round(2)
apply(month_annrets_full,2,sd,na.rm=TRUE) |> round(2)
apply(month_annrets_complete,2,sd,na.rm=TRUE) |> round(2)
```

Now let's compute the ratio of mean return to volatility, which is a measure of the risk-adjusted return. *This calculation will become a Sharpe ratio after we adjust for the risk-free rate.*

```{r nominalsharpe}
(colMeans(daily_annrets_full,na.rm=TRUE)/apply(daily_annrets_full,2,sd,na.rm=TRUE)) |> round(4)
(colMeans(daily_annrets_complete,na.rm=TRUE)/apply(daily_annrets_complete,2,sd,na.rm=TRUE)) |> round(4)
(colMeans(month_annrets_full,na.rm=TRUE)/apply(month_annrets_full,2,sd,na.rm=TRUE)) |> round(4)
(colMeans(month_annrets_complete,na.rm=TRUE)/apply(month_annrets_complete,2,sd,na.rm=TRUE)) |> round(4)
```


### Multivariate Return Distributions

Now let's examine the multivariate return distributions for all the assets. For this, we'll compute the correlation matrix for each version and generate heatmaps to visualize those correlations. *Note: only the full versions require the `use="pairwise.complete` option since the complete versions only include observations where all tokens have price data.*

```{r dailycorrs}
# Full data
cor(daily_annrets_full, use="pairwise.complete") |> round(2)
corrplot(cor(daily_annrets_full, use="pairwise.complete"), method="color")
# Complete data
cor(daily_annrets_complete) |> round(2)
corrplot(cor(daily_annrets_complete), method="color")
```

Now the same with the monthly return series:

```{r monthlycorrs}
# Full data
cor(month_annrets_full, use="pairwise.complete") |> round(2)
corrplot(cor(month_annrets_full, use="pairwise.complete"), method="color")
# Complete data
cor(month_annrets_complete) |> round(2)
corrplot(cor(month_annrets_complete), method="color")
```

### Real Returns

Now let's compute the real returns for each of the assets by inflation-adjusting each nominal return series.

```{r realreturns}
infadj = function(nominal, inflation) {
  realret = (nominal-inflation)/(1+(inflation/100))
  return(realret)
}

daily_annrets_real_full = merge(infadj(daily_annrets_full$AGIX, daily_annrets_full$INF),
                                infadj(daily_annrets_full$SDAO, daily_annrets_full$INF),
                                infadj(daily_annrets_full$NTX, daily_annrets_full$INF),
                                infadj(daily_annrets_full$RJV, daily_annrets_full$INF),
                                infadj(daily_annrets_full$HYPC, daily_annrets_full$INF),
                                infadj(daily_annrets_full$CGV, daily_annrets_full$INF),
                                infadj(daily_annrets_full$SOPH, daily_annrets_full$INF),
                                infadj(daily_annrets_full$BTC, daily_annrets_full$INF),
                                infadj(daily_annrets_full$ETH, daily_annrets_full$INF),
                                infadj(daily_annrets_full$SPY, daily_annrets_full$INF),
                                infadj(daily_annrets_full$NVDA, daily_annrets_full$INF),
                                infadj(daily_annrets_full$RF, daily_annrets_full$INF)
                                )

daily_annrets_real_complete = merge(infadj(daily_annrets_complete$AGIX, daily_annrets_complete$INF),
                                    infadj(daily_annrets_complete$SDAO, daily_annrets_complete$INF),
                                    infadj(daily_annrets_complete$NTX, daily_annrets_complete$INF),
                                    infadj(daily_annrets_complete$RJV, daily_annrets_complete$INF),
                                    infadj(daily_annrets_complete$HYPC, daily_annrets_complete$INF),
                                    infadj(daily_annrets_complete$CGV, daily_annrets_complete$INF),
                                    infadj(daily_annrets_complete$SOPH, daily_annrets_complete$INF),
                                    infadj(daily_annrets_complete$BTC, daily_annrets_complete$INF),
                                    infadj(daily_annrets_complete$ETH, daily_annrets_complete$INF),
                                    infadj(daily_annrets_complete$SPY, daily_annrets_complete$INF),
                                    infadj(daily_annrets_complete$NVDA, daily_annrets_complete$INF),
                                    infadj(daily_annrets_complete$RF, daily_annrets_complete$INF)
                                    )

month_annrets_real_full = merge(infadj(month_annrets_full$AGIX, month_annrets_full$INF),
                                infadj(month_annrets_full$SDAO, month_annrets_full$INF),
                                infadj(month_annrets_full$NTX, month_annrets_full$INF),
                                infadj(month_annrets_full$RJV, month_annrets_full$INF),
                                infadj(month_annrets_full$HYPC, month_annrets_full$INF),
                                infadj(month_annrets_full$CGV, month_annrets_full$INF),
                                infadj(month_annrets_full$SOPH, month_annrets_full$INF),
                                infadj(month_annrets_full$BTC, month_annrets_full$INF),
                                infadj(month_annrets_full$ETH, month_annrets_full$INF),
                                infadj(month_annrets_full$SPY, month_annrets_full$INF),
                                infadj(month_annrets_full$NVDA, month_annrets_full$INF),
                                infadj(month_annrets_full$RF, month_annrets_full$INF)
                                )

month_annrets_real_complete = merge(infadj(month_annrets_complete$AGIX, month_annrets_complete$INF),
                                    infadj(month_annrets_complete$SDAO, month_annrets_complete$INF),
                                    infadj(month_annrets_complete$NTX, month_annrets_complete$INF),
                                    infadj(month_annrets_complete$RJV, month_annrets_complete$INF),
                                    infadj(month_annrets_complete$HYPC, month_annrets_complete$INF),
                                    infadj(month_annrets_complete$CGV, month_annrets_complete$INF),
                                    infadj(month_annrets_complete$SOPH, month_annrets_complete$INF),
                                    infadj(month_annrets_complete$BTC, month_annrets_complete$INF),
                                    infadj(month_annrets_complete$ETH, month_annrets_complete$INF),
                                    infadj(month_annrets_complete$SPY, month_annrets_complete$INF),
                                    infadj(month_annrets_complete$NVDA, month_annrets_complete$INF),
                                    infadj(month_annrets_complete$RF, month_annrets_complete$INF)
                                    )
```








### Risk Premiums (Excess Returns)

Now let's compute the risk premiums for each of the assets by subtracting the real risk-free rate of return from the real return series.

```{r riskpremiums}
daily_annrets_xs_full = merge(daily_annrets_real_full$AGIX-daily_annrets_real_full$RF,
                              daily_annrets_real_full$SDAO-daily_annrets_real_full$RF,
                              daily_annrets_real_full$NTX-daily_annrets_real_full$RF,
                              daily_annrets_real_full$RJV-daily_annrets_real_full$RF,
                              daily_annrets_real_full$HYPC-daily_annrets_real_full$RF,
                              daily_annrets_real_full$CGV-daily_annrets_real_full$RF,
                              daily_annrets_real_full$SOPH-daily_annrets_real_full$RF,
                              daily_annrets_real_full$BTC-daily_annrets_real_full$RF,
                              daily_annrets_real_full$ETH-daily_annrets_real_full$RF,
                              daily_annrets_real_full$SPY-daily_annrets_real_full$RF,
                              daily_annrets_real_full$NVDA-daily_annrets_real_full$RF
                              )

daily_annrets_xs_complete = merge(daily_annrets_real_complete$AGIX-daily_annrets_real_complete$RF,
                                  daily_annrets_real_complete$SDAO-daily_annrets_real_complete$RF,
                                  daily_annrets_real_complete$NTX-daily_annrets_real_complete$RF,
                                  daily_annrets_real_complete$RJV-daily_annrets_real_complete$RF,
                                  daily_annrets_real_complete$HYPC-daily_annrets_real_complete$RF,
                                  daily_annrets_real_complete$CGV-daily_annrets_real_complete$RF,
                                  daily_annrets_real_complete$SOPH-daily_annrets_real_complete$RF,
                                  daily_annrets_real_complete$BTC-daily_annrets_real_complete$RF,
                                  daily_annrets_real_complete$ETH-daily_annrets_real_complete$RF,
                                  daily_annrets_real_complete$SPY-daily_annrets_real_complete$RF,
                                  daily_annrets_real_complete$NVDA-daily_annrets_real_complete$RF
                                  )

month_annrets_xs_full = merge(month_annrets_real_full$AGIX-month_annrets_real_full$RF,
                              month_annrets_real_full$SDAO-month_annrets_real_full$RF,
                              month_annrets_real_full$NTX-month_annrets_real_full$RF,
                              month_annrets_real_full$RJV-month_annrets_real_full$RF,
                              month_annrets_real_full$HYPC-month_annrets_real_full$RF,
                              month_annrets_real_full$CGV-month_annrets_real_full$RF,
                              month_annrets_real_full$SOPH-month_annrets_real_full$RF,
                              month_annrets_real_full$BTC-month_annrets_real_full$RF,
                              month_annrets_real_full$ETH-month_annrets_real_full$RF,
                              month_annrets_real_full$SPY-month_annrets_real_full$RF,
                              month_annrets_real_full$NVDA-month_annrets_real_full$RF
                              )

month_annrets_xs_complete = merge(month_annrets_real_complete$AGIX-month_annrets_real_complete$RF,
                                  month_annrets_real_complete$SDAO-month_annrets_real_complete$RF,
                                  month_annrets_real_complete$NTX-month_annrets_real_complete$RF,
                                  month_annrets_real_complete$RJV-month_annrets_real_complete$RF,
                                  month_annrets_real_complete$HYPC-month_annrets_real_complete$RF,
                                  month_annrets_real_complete$CGV-month_annrets_real_complete$RF,
                                  month_annrets_real_complete$SOPH-month_annrets_real_complete$RF,
                                  month_annrets_real_complete$BTC-month_annrets_real_complete$RF,
                                  month_annrets_real_complete$ETH-month_annrets_real_complete$RF,
                                  month_annrets_real_complete$SPY-month_annrets_real_complete$RF,
                                  month_annrets_real_complete$NVDA-month_annrets_real_complete$RF
                                  )
```

### Risk Premium Distributions

Now let's examine the correlations of the risk premiums for each of the assets.

```{r riskpremiumcorrs_daily}
# Full data
cor(daily_annrets_xs_full, use="pairwise.complete") |> round(2)
corrplot(cor(daily_annrets_xs_full, use="pairwise.complete"), method="color")
# Complete data
cor(daily_annrets_xs_complete) |> round(2)
corrplot(cor(daily_annrets_xs_complete), method="color")
```

Now the same with the monthly risk premiums:

```{r riskpremiumcorrs_monthly}
# Full data
cor(month_annrets_xs_full, use="pairwise.complete") |> round(2)
corrplot(cor(month_annrets_xs_full, use="pairwise.complete"), method="color")
# Complete data
cor(month_annrets_xs_complete) |> round(2)
corrplot(cor(month_annrets_xs_complete), method="color")
```











## ETH-adjusted Returns

Now let's examine the relationship of the returns on the SingularityNET tokens to that of Ethereum, which is the blockchain that the tokens primarily transact on.

First up is the SingularityNET token (AGIX):

```{r agixregs}
AGIXfit_daily = lm(AGIX~ETH, data=daily_annrets)
summary(AGIXfit_daily)
ggplot(daily_annrets,aes(y=AGIX, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$AGIXresid = xts(resid(AGIXfit_daily), order.by=as.Date(names(resid(AGIXfit_daily))))

AGIXfit_month = lm(AGIX~ETH, data=month_annrets)
summary(AGIXfit_month)
ggplot(month_annrets,aes(y=AGIX, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets2 = data.frame(date=names(resid(AGIXfit_month)))
month_annrets2$AGIXresids = resid(AGIXfit_month)
```

Next is the SingularityDAO token (SDAO):

```{r sdaoregs}
SDAOfit_daily = lm(SDAO~ETH, data=daily_annrets)
summary(SDAOfit_daily)
ggplot(daily_annrets,aes(y=SDAO, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$SDAOresid = xts(resid(SDAOfit_daily), order.by=as.Date(names(resid(SDAOfit_daily))))

SDAOfit_weeks = lm(SDAO~ETH, data=weeks_annrets)
summary(SDAOfit_weeks)
ggplot(weeks_annrets,aes(y=SDAO, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$SDAOresids = xts(resid(SDAOfit_weeks), order.by=as.Date(names(resid(SDAOfit_weeks))))

SDAOfit_month = lm(SDAO~ETH, data=month_annrets)
summary(SDAOfit_month)
ggplot(month_annrets,aes(y=SDAO, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(SDAOfit_month)))
month_annrets3$SDAOresids = resid(SDAOfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

Then the NuNet token (NTX):

```{r ntxregs}
NTXfit_daily = lm(NTX~ETH, data=daily_annrets)
summary(NTXfit_daily)
ggplot(daily_annrets,aes(y=NTX, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$NTXresid = xts(resid(NTXfit_daily), order.by=as.Date(names(resid(NTXfit_daily))))

NTXfit_weeks = lm(NTX~ETH, data=weeks_annrets)
summary(NTXfit_weeks)
ggplot(weeks_annrets,aes(y=NTX, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$NTXresids = xts(resid(NTXfit_weeks), order.by=as.Date(names(resid(NTXfit_weeks))))

NTXfit_month = lm(NTX~ETH, data=month_annrets)
summary(NTXfit_month)
ggplot(month_annrets,aes(y=NTX, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(NTXfit_month)))
month_annrets3$NTXresids = resid(NTXfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

Next is the Rejuve token (RJV):

```{r rjvregs}
RJVfit_daily = lm(RJV~ETH, data=daily_annrets)
summary(RJVfit_daily)
ggplot(daily_annrets,aes(y=RJV, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$RJVresid = xts(resid(RJVfit_daily), order.by=as.Date(names(resid(RJVfit_daily))))

RJVfit_weeks = lm(RJV~ETH, data=weeks_annrets)
summary(RJVfit_weeks)
ggplot(weeks_annrets,aes(y=RJV, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$RJVresids = xts(resid(RJVfit_weeks), order.by=as.Date(names(resid(RJVfit_weeks))))

RJVfit_month = lm(RJV~ETH, data=month_annrets)
summary(RJVfit_month)
ggplot(month_annrets,aes(y=RJV, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(RJVfit_month)))
month_annrets3$RJVresids = resid(RJVfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

Then the HyperCycle token (HYPC):

```{r hypcregs}
HYPCfit_daily = lm(HYPC~ETH, data=daily_annrets)
summary(HYPCfit_daily)
ggplot(daily_annrets,aes(y=HYPC, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$HYPCresid = xts(resid(HYPCfit_daily), order.by=as.Date(names(resid(HYPCfit_daily))))

HYPCfit_weeks = lm(HYPC~ETH, data=weeks_annrets)
summary(HYPCfit_weeks)
ggplot(weeks_annrets,aes(y=HYPC, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$HYPCresids = xts(resid(HYPCfit_weeks), order.by=as.Date(names(resid(HYPCfit_weeks))))

HYPCfit_month = lm(HYPC~ETH, data=month_annrets)
summary(HYPCfit_month)
ggplot(month_annrets,aes(y=HYPC, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(HYPCfit_month)))
month_annrets3$HYPCresids = resid(HYPCfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

Next is the Cogito token (CGV):

```{r cgvregs}
CGVfit_daily = lm(CGV~ETH, data=daily_annrets)
summary(CGVfit_daily)
ggplot(daily_annrets,aes(y=CGV, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$CGVresid = xts(resid(CGVfit_daily), order.by=as.Date(names(resid(CGVfit_daily))))

CGVfit_weeks = lm(CGV~ETH, data=weeks_annrets)
summary(CGVfit_weeks)
ggplot(weeks_annrets,aes(y=CGV, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$CGVresids = xts(resid(CGVfit_weeks), order.by=as.Date(names(resid(CGVfit_weeks))))

CGVfit_month = lm(CGV~ETH, data=month_annrets)
summary(CGVfit_month)
ggplot(month_annrets,aes(y=CGV, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(CGVfit_month)))
month_annrets3$CGVresids = resid(CGVfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

Lastly is the Sophiaverse token (SOPH):

```{r sophregs}
SOPHfit_daily = lm(SOPH~ETH, data=daily_annrets)
summary(SOPHfit_daily)
ggplot(daily_annrets,aes(y=SOPH, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$SOPHresid = xts(resid(SOPHfit_daily), order.by=as.Date(names(resid(SOPHfit_daily))))

SOPHfit_weeks = lm(SOPH~ETH, data=weeks_annrets)
summary(SOPHfit_weeks)
ggplot(weeks_annrets,aes(y=SOPH, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$SOPHresids = xts(resid(SOPHfit_weeks), order.by=as.Date(names(resid(SOPHfit_weeks))))

SOPHfit_month = lm(SOPH~ETH, data=month_annrets)
summary(SOPHfit_month)
ggplot(month_annrets,aes(y=SOPH, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(SOPHfit_month)))
month_annrets3$SOPHresids = resid(SOPHfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

Lastly, let's look at the ecosystem as a whole:

```{r snetregs}
SNETfit_daily = lm(SNET~ETH, data=daily_annrets)
summary(SNETfit_daily)
ggplot(daily_annrets,aes(y=SNET, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
daily_annrets$SNETresid = xts(resid(SNETfit_daily), order.by=as.Date(names(resid(SNETfit_daily))))

SNETfit_weeks = lm(SNET~ETH, data=weeks_annrets)
summary(SNETfit_weeks)
ggplot(weeks_annrets,aes(y=SNET, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
weeks_annrets$SNETresids = xts(resid(SNETfit_weeks), order.by=as.Date(names(resid(SNETfit_weeks))))

SNETfit_month = lm(SNET~ETH, data=month_annrets)
summary(SNETfit_month)
ggplot(month_annrets,aes(y=SNET, x=ETH))+
  geom_point()+
  geom_smooth(method="lm")
month_annrets3 = data.frame(date=names(resid(SNETfit_month)))
month_annrets3$SNETresids = resid(SNETfit_month)
month_annrets2 = merge(month_annrets2, month_annrets3, all.x=TRUE)
```

### Residual Correlations

Now that we have the residual series for each of the coins/tokens, let's look at the correlations between them. These represent the correlations of the asset returns after removing the effects that are explained by their relationship with Ethereum.

```{r dailyresidcors}
cor(daily_annrets[,10:17], use="pairwise.complete.obs") |> round(2)
```

```{r weeksresidcors}
cor(weeks_annrets[,10:17], use="pairwise.complete.obs") |> round(2)
```

```{r monthresidcors}
cor(month_annrets2[,-1], use="pairwise.complete.obs") |> round(2)
```

